# 第一章 打好基础
## 目錄
* [软体开发过程](#软体开发过程)
* [构建活动](#构建活动)
* [前期准备重要](#前期准备重要)
* [跌代、序列开发比较](#跌代开发)
* [明确需求](#明确需求)
* [需求核对表](#需求核对表)


## 软体开发过程
* 定义问题（problem definition）
* 需求分析（requirements development）
* 规划构建（construction planning）☺
* 软件架构（software architecture），或高层设计（high-level design）
* 详细设计（detailed design）☺
* 编码与调试（coding and debugging）
* 单元测试（unit testing）☺
* 集成测试（integration testing）☺
* 集成（integration）☺
* 系统测试（system testing）
* 保障维护（corrective maintenance）☺

笑脸为大部分主要著重的过程，如下图灰色部分

![Alt text](https://raw.githubusercontent.com/MingYi-Chen/sharedPhotoes/master/processOfNormal.png)

## 构建活动 （30%-80%）之重要有哪些具体项目？
* 验证有关的基础工作已经完成，因此构建活动可以顺利地进行下去。
* 确定如何测试所写的代码。
* 设计并编写类(class)和子程序(routine)。
* 创建并命名变量(variable)和命名常量(named constant).
* 选择控制结构(control structure)，组织语句块。
* 对你的代码进行单元测试和集成测试，并排除其中的错误。
* 评审开发团队其他成员的底层设计和代码，并让他们评审你的工作。
* 润饰代码，仔细进行代码的格式化和注释。
* 将单独开发的多个软件组件集成为一体。
* 调整代码(tuning code)，让它更快、更省资源。

不同程序员建构生产率 10至20倍

## 前期准备重要
测试只是质量保证的一部分，测试不可能检查出"使用错误方法制作正确的产品"。
准备工作的中心目标？降低风险。
有些程序员确实知道如何进行前期工作，但是他们并没有做，无法抵挡"尽快开始编码"的欲望。
前期准备工作，比"先做一个错误的东西出来，然后扔掉，从头来过"成本还要来的低。

以下图片指开发的哪个期间发现了问题，造成的成本。可以看到

需求>架构>构建，足以证明前期的重要性。

目标不是赶紧写代码，而是江需求与设计详细的研究，想不出有任何有可能遇到的问题。

![Alt text](https://raw.githubusercontent.com/MingYi-Chen/sharedPhotoes/master/DefectIsDetected.png)

## 跌代开发 vs 序列式开发
没有需求详细分析
序列式开发(1000000) vs 跌代式开发(875000)
跌代式开发成本比较省。
![Alt text](https://raw.githubusercontent.com/MingYi-Chen/sharedPhotoes/master/cost1.png)

有需求详细分析
序列式开发(600000) vs 跌代式开发(550000)
跌代式开发成本比较省。

![Alt text](https://raw.githubusercontent.com/MingYi-Chen/sharedPhotoes/master/cost2.png)

总结：由于跌代式开发，提早遇到问题及早解决。

## 明确需求
明确需求不只确保用户驾驭系统的功能。若是需求错误，会造成整个系统都要重新制作的风险；若非需求错误，则只需要修改代码。

需求错误发现阶段：
* 架构检测到求错误 修复成本 3 倍
* 编码阶段检测到需求错误 修复成本 5-10 倍
* 系统测试阶段检测到需求错误 修复 10倍
* 上线后 修复 10倍 至 100倍

所以问题、需求的定义非常重要，如基石。

![Alt text](https://raw.githubusercontent.com/MingYi-Chen/sharedPhotoes/master/ProblemDefine.png)

## 需求核对表

针对功能需求：
* 是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等？
* 是否详细定义了系统的全部输出，包括其目的地、精度、取值范围、出现频率格式等？
* 是否详细定义了所有的输出格式(如：web页面、报表等)？
* 是否详细定义了所有硬件及软件的外部接口？
* 是否详细定义了全部外部通信接口，包括握手协议、纠错协议、通信协议等？
* 是否列出了用户所要做的全部事情？
* 是否详细定义了每个任务所用数据，以及每个任务得到的数据

针对非功能需求（质量需求）
* 是否为全部必要的操作，从用户的角度，详细描述的期望的响应时间 ？
* 是否详细描述了其他与计时有关的考虑，如处理时间、数据传输率、系统吞吐量等？
* 是否详细定义了安全级别
* 是否详细定义了可靠性，包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检查与回复的策略等？
* 是否详细定义了机器内存和剩余硬盘空间最小值？
* 是否详细定义了系统的可维护性，包括适应特定功能的变更、操作环境的变更、与其他软件接口变更的能力？
* 是否包含对“成功”的定义，“失败”的定义？

需求的质量
* 需求是用户书写的吗？
* 每条需求都不与其他需求冲突吗？
* 是否详细定义了相互竞争的特性之间的权衡
* 是否避免在需求中规定设计(方案)
* 需求是否在详细程度上保持相当一致的水平？有些需求应当更详细的描述吗？有些需求应该更粗略的描述吗？
* 需求是否足够清晰，即使转交给一个独立的小组去构建，他们也能理解吗？开发者也这么想吗？
* 每个条款都与待解决的问题及解决方案相关吗？能从每个条款上溯到它的问题中的对应跟源吗？
* 是否每条需求都是可测试的？是否可应进行独立的测试，以检验满不满足各项需求
* 是否描述了所有可能对需求的改动，包括各项改动的可能性

需求的完备性
* 对于在开始开发之前无法获得信息，是否详细描述了信息不完全的区域？
* 需求的完备度是否达到这种程度：如果产品满足所有需求，那么它就是可接受的
* 你对全部需求都感觉舒服吗？你是否已经去掉了那些不可能完成的需求—那些只是为了安抚客户和老板的东西


架构核对表

针对各架构主题

* 程序的整体组织结构是否清晰？是否包含一个良好的架构全局观（及其理由）？
* 是否明确定义了主要的构造块（包括每个构造块的职责范围及与其他构造块的接口）？
* 是否明显涵盖了“需求”中列出的所有功能（每个功能对应的构造块不太多也不太少）？
* 是否描述并论证了那些最关键的类？
* 是否描述并论证了数据设计？
* 是否详细定义了数据库的组织结构和内容？
* 是否指出了所用关键的业务规则，并描述其对系统的影响？
* 是否描述了用户界面设计的策略？
* 是否将用户界面模块化，使界面的变更不会影响程序其余部分？
* 是否描述并论证了处理I/O的策略？
* 是否估算了稀缺资源（如线程、数据库连接、句柄、网络带宽等）的使用量，是否描述并论证了资源管理的策略？
* 是否描述了架构的安全需求？
* 架构是否为每个类、每个子系统、或每个功能域(functionality area)提出空间与时间预算？
* 架构是否描述了如何达到可伸缩性？
* 架构是否关注互操作性？
* 是否描述了国际化/本地化的策略？
* 是否提供了一套内聚的错误处理策略？
* 是否规定了容错的办法（如果需要）？
* 是否证实了系统各个部分的技术可行性？
* 是否详细描述了过度工程(overengineering)的方法？
* 是否包含了必要的“买 vs. 造”的决策？
* 架构是否描述了如何加工被复用的代码，使之符合其他架构目标？
* 是否将架构设计得能够适应很可能出现的变更？

架构的总体质量

* 架构是否解决了全部需求？
* 有没有哪个部分是“过度架构/overarchitected”或“欠架构/underarchitected”？是否明确宣布了在这方面的预期指标？
* 整个架构是否在概念上协调一致？
* 顶层设计是否独立于用作实现它的机器和语言？
* 是否说明了所有主要的决策的动机？
* 你，作为一名实现该系统的程序员，是否对这个架构感觉良好？

需求、架构及前期计画方面投入 10~20%的工作量 和 20%~30%的时。
